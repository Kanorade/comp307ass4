import java.util.*;

public class Utility {

    /**
     * Calculate the Euclidean distance between two VRP nodes
     * @param node1 the first VRP node
     * @param node2 the second VRP node
     * @return the Euclidean distance between node1 and node2
     */
    public static double calculateEuclideanDistance(VRPNode node1, VRPNode node2) {
        double xDiff = node2.getX() - node1.getX();
        double yDiff = node2.getY() - node1.getY();
        return Math.sqrt(Math.pow(xDiff, 2.0) + Math.pow(yDiff, 2.0));
    }

    /**
     * Calculate the total cost of a VRP solution under a VRP instance.
     * The total cost is the sum of all the Euclidean distance between adjacent nodes in the routes.
     * @param solution the VRP solution.
     * @param instance the VRP instance.
     * @return the total cost of the solution.
     */
    public static double calculateTotalCost(VRPSolution solution, VRPInstance instance) {
        // TODO: Implement the function to calculate the total cost of the solution.
        return 0.0;
    }

    /**
     * Generate a VRP solution for a VRP instance using the nearest neighbour heuristic.
     * @param instance the VRP instance.
     * @return the VRP solution generated by the nearest neighbour heuristic.
     */
    public static VRPSolution nearestNeighbourHeuristic(VRPInstance instance) {
        // TODO: Implement the nearest neighbour heuristic.
        // Have a way to keep track of visited nodes
        Map<Integer, VRPNode> visited = new HashMap<>();
        visited.put(instance.getDepot().getID(), instance.getDepot());

        // Initialise solution, well, a list of routes
        List<List<Integer>> routes = new ArrayList<>();

        // Find routes until every node is visited
        // Note: This assumes no single node has a demand higher than van capacity. In real life,
        //      there will be places that may need multiple vans to visit the same node.
        // 2nd Note: Originally I included the depot node in the routes (eg. each route starting and ending
        //      with node 1) I left those lines in but commented out.
        while (visited.size() != instance.getNodes().size()) {
            // new empty van
            double vanLoad = 0;   // Van load
            // start new route, starting at depot
            List<Integer> route = new ArrayList<>();
            VRPNode currentLocation = instance.getDepot();
            //route.add(currentLocation.getID());

            // As long as van doesn't exceed capacity and not all nodes are visited it can proceed
            // to the next nearest neighbour
            boolean vanActive = true;
            while (vanActive) {
                VRPNode nearestNeighbour = null;    // Will stay null if every node is visited
                double minDistance = Double.MAX_VALUE;
                for (Map.Entry<Integer, VRPNode> nodeEntry : instance.getNodes().entrySet()) {
                    if (visited.get(nodeEntry.getKey()) == null) {  // only care about places not visited
                        double distance = calculateEuclideanDistance(currentLocation, nodeEntry.getValue());
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestNeighbour = nodeEntry.getValue();
                        }
                    }
                }

                if (nearestNeighbour != null) {  // If an unvisited nearest neighbour is found
                    // check if van won't exceed capacity when visiting nearest neighbour
                    vanLoad += nearestNeighbour.getDemand();
                    if (vanLoad <= instance.getCapacity()) {
                        // Great! Lets this node then.
                        route.add(nearestNeighbour.getID());
                        visited.put(nearestNeighbour.getID(), nearestNeighbour);
                        currentLocation = nearestNeighbour;
                    } else {
                        vanActive = false;  // Can't go any further, let's head back
                        //route.add(instance.getDepot().getID());
                    }
                } else {
                    vanActive = false;  // No more nodes left, head back.
                    //route.add(instance.getDepot().getID());
                }
            }

            // Add route to solution
            routes.add(route);
        }

        return new VRPSolution(routes);
    }

    /**
     * Generate a VRP solution for a VRP instance using the savings heuristic.
     * @param instance the VRP instance.
     * @return the VRP solution generated by the savings heuristic.
     */
    public static VRPSolution savingsHeuristic(VRPInstance instance) {
        // TODO: Implement the savings heuristic.
        return null;
    }

}
