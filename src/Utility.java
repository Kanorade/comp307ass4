import java.util.*;

public class Utility {

    /**
     * Calculate the Euclidean distance between two VRP nodes
     * @param node1 the first VRP node
     * @param node2 the second VRP node
     * @return the Euclidean distance between node1 and node2
     */
    public static double calculateEuclideanDistance(VRPNode node1, VRPNode node2) {
        double xDiff = node2.getX() - node1.getX();
        double yDiff = node2.getY() - node1.getY();
        return Math.sqrt(Math.pow(xDiff, 2.0) + Math.pow(yDiff, 2.0));
    }

    /**
     * Calculate the total cost of a VRP solution under a VRP instance.
     * The total cost is the sum of all the Euclidean distance between adjacent nodes in the routes.
     * @param solution the VRP solution.
     * @param instance the VRP instance.
     * @return the total cost of the solution.
     */
    public static double calculateTotalCost(VRPSolution solution, VRPInstance instance) {
        double totalCost = 0;
        VRPNode depot = instance.getDepot();
        for (List<Integer> route : solution.getRoutes()) {
            VRPNode currentNode = depot;    // start at depot
            for (int node_id : route) {
                VRPNode destNode = instance.getNodes().get(node_id);    // destination node
                totalCost += calculateEuclideanDistance(currentNode, destNode);
                currentNode = destNode;
            }
            totalCost += calculateEuclideanDistance(currentNode, depot);
        }
        return totalCost;
    }

    /**
     * Generate a VRP solution for a VRP instance using the nearest neighbour heuristic.
     * @param instance the VRP instance.
     * @return the VRP solution generated by the nearest neighbour heuristic.
     */
    public static VRPSolution nearestNeighbourHeuristic(VRPInstance instance) {
        // Have a way to keep track of visited nodes
        Map<Integer, VRPNode> visited = new HashMap<>();
        visited.put(instance.getDepot().getID(), instance.getDepot());

        // Initialise solution, well, a list of routes
        List<List<Integer>> routes = new ArrayList<>();

        // Find routes until every node is visited
        // Note: This assumes no single node has a demand higher than van capacity. In real life,
        //      there will be places that may need multiple vans to visit the same node.
        // 2nd Note: Originally I included the depot node in the routes (eg. each route starting and ending
        //      with node 1) I left those lines in but commented out.
        while (visited.size() != instance.getNodes().size()) {
            // new empty van
            double vanLoad = 0;   // Van load
            // start new route, starting at depot
            List<Integer> route = new ArrayList<>();
            VRPNode currentLocation = instance.getDepot();
            //route.add(currentLocation.getID());

            // As long as van doesn't exceed capacity and not all nodes are visited it can proceed
            // to the next nearest neighbour
            boolean vanActive = true;
            while (vanActive) {
                VRPNode nearestNeighbour = null;    // Will stay null if every node is visited
                double minDistance = Double.MAX_VALUE;
                for (Map.Entry<Integer, VRPNode> nodeEntry : instance.getNodes().entrySet()) {
                    if (visited.get(nodeEntry.getKey()) == null) {  // only care about places not visited
                        double distance = calculateEuclideanDistance(currentLocation, nodeEntry.getValue());
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestNeighbour = nodeEntry.getValue();
                        }
                    }
                }

                if (nearestNeighbour != null) {  // If an unvisited nearest neighbour is found
                    // check if van won't exceed capacity when visiting nearest neighbour
                    vanLoad += nearestNeighbour.getDemand();
                    if (vanLoad <= instance.getCapacity()) {
                        // Great! Lets this node then.
                        route.add(nearestNeighbour.getID());
                        visited.put(nearestNeighbour.getID(), nearestNeighbour);
                        currentLocation = nearestNeighbour;
                    } else {
                        vanActive = false;  // Can't go any further, let's head back
                        //route.add(instance.getDepot().getID());
                    }
                } else {
                    vanActive = false;  // No more nodes left, head back.
                    //route.add(instance.getDepot().getID());
                }
            }

            // Add route to solution
            routes.add(route);
        }

        return new VRPSolution(routes);
    }

    /**
     * Generate a VRP solution for a VRP instance using the savings heuristic.
     * @param instance the VRP instance.
     * @return the VRP solution generated by the savings heuristic.
     */
    public static VRPSolution savingsHeuristic(VRPInstance instance) {
        // Initialize routes for each node except depot
        List<List<Integer>> routes = new ArrayList<>();
        for (Map.Entry<Integer, VRPNode> nodeEntry : instance.getNodes().entrySet()) {
            if (nodeEntry.getKey() != instance.getDepot().getID()) { // skip depot
                List<Integer> route = new ArrayList<>();
                route.add(nodeEntry.getKey());
                routes.add(route);
            }
        }

        // Compute and store the savings for each possible route merge
        record NodePair(VRPNode node1, VRPNode node2) {}
        Map<NodePair, Double> savings = new HashMap<>();
        VRPNode depot = instance.getDepot();
        for (Map.Entry<Integer, VRPNode> nodeEntry1 : instance.getNodes().entrySet()) {
            VRPNode node1 = nodeEntry1.getValue();
            for (Map.Entry<Integer, VRPNode> nodeEntry2 : instance.getNodes().entrySet()) {
                VRPNode node2 = nodeEntry2.getValue();
                if (node1 != node2) {
                    // Compute cost savings if the two routes merged and store it
                    double saved = calculateEuclideanDistance(node1, depot) +
                            calculateEuclideanDistance(depot, node2) -
                            calculateEuclideanDistance(node1, node2);
                    savings.put(new NodePair(node1, node2), saved);
                }
            }
        }

        // Check all the possible/feasible route merges. feasible being within truck capacity.
        boolean mergesLeft = true;
        while (mergesLeft) {
            double mostSaved = 0;
            List<Integer> bestRoute1 = null;
            List<Integer> bestRoute2 = null;
            for (List<Integer> route1 : routes) {
                for (List<Integer> route2 : routes) {
                    if (route1 != route2) {
                        // need to check saving by comparing the last node in route 1 and the first node in route 2
                        int r1_last_id = route1.get(route1.size() - 1);
                        int r2_first_id = route2.get(0);
                        NodePair nodePair = new NodePair(
                                instance.getNodes().get(r1_last_id),
                                instance.getNodes().get(r2_first_id));
                        double saved = savings.get(nodePair);
                        if (saved > mostSaved) {
                            // need to check if feasible
                            double totalLoad = 0;
                            for (int node_id : route1) {
                                totalLoad += instance.getNodes().get(node_id).getDemand();
                            }
                            for (int node_id : route2) {
                                totalLoad += instance.getNodes().get(node_id).getDemand();
                            }
                            if (totalLoad <= instance.getCapacity()) {
                                mostSaved = saved;
                                bestRoute1 = route1;
                                bestRoute2 = route2;
                            }
                        }
                    }
                }
            }

            // Merge routes with the largest saving
            if (mostSaved == 0) {   // No possible merges if zero
                mergesLeft = false;
            } else {
                bestRoute1.addAll(bestRoute2);
                routes.remove(bestRoute2);
            }
        }

        return new VRPSolution(routes);
    }

}
